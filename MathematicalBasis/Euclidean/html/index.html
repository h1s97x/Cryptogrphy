<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta content="" name="description">
    <meta content="True" name="HandheldFriendly">
    <meta content="320" name="MobileOptimized">
    <meta content="initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport">
    <title>Euclidean算法 - Documentation</title>
    <link href="css/style.css" rel="stylesheet">
    <link href="css/prettify.css" rel="stylesheet">

    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script>
MathJax = {    
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    //tags: 'ams'  // should be 'ams', 'none', or 'all'
  }
};

    </script>
    <script async id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>

<div class="wrapper">
    <header>
        <div class="container">
            <h2 class="lone-header">数缘科技 - Euclidean算法</h2>
        </div>
    </header>
    <section>
        <div class="container">
            <ul class="docs-nav" id="menu-left">
                <li><strong>实验介绍</strong></li>
                <li><a class=" " href="#Euclidean算法实验说明">Euclidean算法实验说明</a></li>
                <li class="separator"></li>
                <li><strong>Euclidean算法介绍</strong></li>
                <li><a class=" " href="#算法简介">算法简介</a></li>
                <li><a class=" " href="#计算证明">计算证明</a></li>
                <li><a class=" " href="#示例">应用示例</a></li>
                <li><a class=" " href="#扩展Euclidean算法">扩展Euclidean算法</a></li>
                <li><a class=" " href="#模反元素">模反元素</a></li>
            </ul>
            <div class="docs-content">
                <!-- <h2> 实验介绍</h2> -->
                <h3 id="Euclidean算法实验说明"> Euclidean算法实验说明</h3>
                <p>本实验支持自定义两个整数进行PC端
                    <emphasis>任意长度</emphasis>
                    的Euclidean算法实验。
                </p>
                <p>以下为本实验的重要提示：</p>
                <ul>
                    <li>数据格式：软件右侧交互栏部分可以进行Euclidean算法实验中两个整数 $a$ 和 $b$ 的输入。本实验中支持
                        <emphasis>任意长度</emphasis>
                        的整数输入。输入框内已填入默认值，可参考默认值进行设置。
                    </li>
                    <li>整数 $a$ 输入：可通过交互栏的“a (Int)”文本框输入。</li>
                    <li>整数 $b$ 输入：可通过交互栏的“b (Int)”文本框输入。</li>
                    <li>计算结果：交互栏部分包含一个“Gcd”按钮，点击即可求得Euclidean算法的实验结果。</li>
                </ul>
                <p class="separator"></p>
                <h3 id="算法简介"> 算法简介</h3>
                <p>Euclidean算法（Euclidean Algorithm）是数论中的一项基本技术，它通过一个简单的过程来确定两个正整数的最大公约数。Euclidean算法基于下面的定理：</p>
                <p>两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数。最大公约数（Greatest Common Divisor）缩写为GCD。对任何非负的整数 $a$ 和 $b$：</p>
                <p align="center">gcd$(a,b)$ = gcd $(b,a \bmod b) (a\geq b)$</p>
                <p>可重复使用上式求出最大公约数。重复计算结束的条件是后一个整数等于0，此时前一个数即为二者的最大公约数。</p>
                <h3 id="计算证明"> 计算证明</h3>
                <p>对上述的定理进行如下证明：</p>
                <p>$a$ 可以表示为：$a=kb+r$（$a$、$b$、$k$、$r$ 都为正整数，且 $r < b$），则 $r=a \bmod b$。</p>
                <p>假设 $d$ 是 $a$、$b$ 的一个公约数 ，由 $r=a-kb$，两边同时除以 $d$，得 $r/d=a/d-kb/d=m$，由等式右边知 $m$ 为整数，因此 $d$ 是 $r$ 的公约数，即
                    $d$ 也是 $b$，$a \bmod b$ 的公约数。</p>
                <p>假设 $d$ 是 $b$、$a \bmod b$ 的一个公约数 ，由 $a=kb+r$，两边同时除以 $d$，得 $a/d=kb/d+r/d=m$，由等式右边知 $m$ 为整数，因此 $d$ 是 $a$
                    的公约数，即 $d$ 也是 $a$，$b$ 的公约数。</p>
                <p>因此 $(a,b)$ 和 $(b,a \bmod b)$ 的公约数一样，其最大公约数也必然相等。</p>
                <h3 id="示例"> 应用示例</h3>
                <p>gcd（18，12）= gcd（12，18 $\bmod$ 12）= gcd（12，6）= gcd（6，12 $\bmod$ 6）= gcd（6，0）= 6。</p>
                <h3 id="扩展Euclidean算法"> 扩展Euclidean算法</h3>
                <p>扩展Euclidean算法（Extended Euclidean algorithm）是Euclidean算法（又叫辗转相除法）的扩展。已知整数 $a$ 和 $b$，扩展欧几里得算法可以在求得 $a$
                    和 $b$的最大公约数的同时，能找到整数 $x$ 和 $y$（其中一个很可能是负数），使它们满足贝祖等式：</p>
                <p align="center">$ax+by=$ gcd$(a,b)$</p>
                <p>如果 $a$ 是负数，可以把问题转化成 $|a|(-x)+by=$gcd$(|a|,b)$，然后令$x'=(-x)$。</p>
                <p>扩展欧几里得算法可以用来计算模反元素(也叫模逆元)，而模反元素在RSA加密算法中有举足轻重的地位。</p>
                <h3 id="模反元素"> 模反元素</h3>
                <p>对于整数 $a$、$p$，如果存在整数 $b$，满足 $ab \bmod p =1$，则说，$b$ 是 $a$ 的模 $p$ 逆元。</p>
                <p>定理：a存在模p的乘法逆元的充要条件是gcd$(a,p) = 1$。</p>
                <p>下面对该定理进行证明，首先证明充分性：</p>
                <p>如果gcd$(a,p) = 1$，根据欧拉定理，$a\varphi(p) \equiv 1 \bmod p$，因此显然$a\varphi(p) - 1 \bmod p$ 是 $a$ 的模 $p$
                    乘法逆元。</p>
                <p>再证明必要性：</p>
                <p>假设存在 $a$ 模 $p$ 的乘法逆元为 $b$，$ab \equiv 1 \bmod p$，</p>
                <p>则 $ab = kp +1$，所以$1=ab-kp$。</p>
                <p>因为gcd$(a,p) = b$，所以 $d$ 是1的一个公约数。</p>
                <p>因此 $d$ 只能为1。</p>
                <p class="separator"></p>
                <p><a href="#"> 回到顶部</a></p>
                <p></p>
            </div>
        </div>
    </section>

    <section class="vibrant centered">
        <div class="container">
            <h6> &copy; 北京数缘科技有限公司，鲁ICP备09017473号，Copyright (c) 2015 MathMagic Technology Co., Ltd. All Rights
                Reserved.</h6>
            <h6>地址：北京市海淀区中关村南大街9号理工科技大厦1412室，邮编：100081，电话：+86-15253166443，邮箱：sales@mathmagic.cn。</h6>
        </div>
    </section>
</div>
</body>
</html>
